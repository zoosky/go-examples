
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-examples/cmd/app/main.go (0.0%)</option>
				
				<option value="file1">go-examples/cmd/calcclient/main.go (0.0%)</option>
				
				<option value="file2">go-examples/cmd/calcservice/main.go (0.0%)</option>
				
				<option value="file3">go-examples/examples/bad_structure/bad.go (0.0%)</option>
				
				<option value="file4">go-examples/examples/good_structure/good.go (0.0%)</option>
				
				<option value="file5">go-examples/examples/package_import.go (0.0%)</option>
				
				<option value="file6">go-examples/pkg/calculator/calculator.go (96.6%)</option>
				
				<option value="file7">go-examples/pkg/logger/logger.go (55.2%)</option>
				
				<option value="file8">go-examples/pkg/slogger/sloggger.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides a simple interactive calculator application
// that uses the calculator package with logging capabilities.
package main

import (
        "bufio"
        "fmt"
        "os"
        "strconv"
        "strings"

        "go-examples/pkg/calculator"
        "go-examples/pkg/logger"
)

func main() <span class="cov0" title="0">{
        // Initialize logger
        log, err := logger.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">log.Info("Starting calculator application")

        // Create calculator instance with logger
        calc := calculator.NewCalculator(log)
        fmt.Println("Simple Calculator")
        fmt.Println("=================")
        fmt.Println("Available operations: add, subtract, quit")
        fmt.Println("Example usage: add 5 3")
        fmt.Println()

        scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("&gt; ")
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := scanner.Text()
                log.Debugf("User input: %s", input)

                if input == "quit" || input == "exit" || input == "q" </span><span class="cov0" title="0">{
                        log.Info("User requested to quit application")
                        fmt.Println("Goodbye!")
                        break</span>
                }

                <span class="cov0" title="0">result, err := processCommand(input, calc, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Command processing error: %v", err)
                        fmt.Printf("Error: %s\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">log.Infof("Successful calculation, result: %d", result)
                fmt.Printf("Result: %d\n", result)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Scanner error: %v", err)
                fmt.Fprintf(os.Stderr, "Reading input: %s\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">log.Info("Application shutting down")</span>
}

func processCommand(input string, calc *calculator.Calculator, log logger.Logger) (int, error) <span class="cov0" title="0">{
        // Split the input into command and arguments
        parts := strings.Fields(input)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid input, expected format: &lt;operation&gt; &lt;number1&gt; &lt;number2&gt;")
        }</span>

        <span class="cov0" title="0">command := strings.ToLower(parts[0])

        // Parse the numbers
        a, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("first number is invalid: %v", err)
        }</span>

        <span class="cov0" title="0">b, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("second number is invalid: %v", err)
        }</span>

        // Perform the operation
        <span class="cov0" title="0">log.Debugf("Processing command: %s with arguments %d and %d", command, a, b)

        switch command </span>{
        case "add":<span class="cov0" title="0">
                return calc.Add(a, b), nil</span>
        case "subtract":<span class="cov0" title="0">
                return calc.Subtract(a, b), nil</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown operation: %s, supported operations are 'add' and 'subtract'", command)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main provides a CLI client for the calculator microservice
package main

import (
        "bufio"
        "bytes"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"
)

// Configuration holds client configuration
type Configuration struct {
        ServerURL string
        Timeout   time.Duration
}

// CalculationRequest represents a calculation API request
type CalculationRequest struct {
        Operation string `json:"operation"`
        A         int    `json:"a"`
        B         int    `json:"b"`
}

// CalculationResponse represents a calculation API response
type CalculationResponse struct {
        Result  int    `json:"result"`
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

func main() <span class="cov0" title="0">{
        // Parse configuration from command line flags
        config := parseFlags()

        // Check if the service is available
        if !checkServiceHealth(config) </span><span class="cov0" title="0">{
                fmt.Println("Error: Calculator service is not available")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Calculator Client")
        fmt.Println("================")
        fmt.Printf("Connected to: %s\n", config.ServerURL)
        fmt.Println("Available operations: add, subtract, multiply, divide, quit")
        fmt.Println("Example usage: add 5 3")
        fmt.Println()

        scanner := bufio.NewScanner(os.Stdin)

        for </span><span class="cov0" title="0">{
                fmt.Print("&gt; ")
                if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">input := scanner.Text()
                fmt.Printf("Executing: %s\n", input)

                if input == "quit" || input == "exit" || input == "q" </span><span class="cov0" title="0">{
                        fmt.Println("Goodbye!")
                        break</span>
                }

                <span class="cov0" title="0">result, err := processCommand(input, config)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error: %s\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("Result: %d\n", result)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Reading input: %s\n", err)
                os.Exit(1)
        }</span>
}

// parseFlags parses command line flags and returns configuration
func parseFlags() Configuration <span class="cov0" title="0">{
        serverURL := flag.String("server", "http://localhost:8080", "Calculator service URL")
        timeout := flag.Int("timeout", 5, "Request timeout in seconds")
        flag.Parse()

        return Configuration{
                ServerURL: *serverURL,
                Timeout:   time.Duration(*timeout) * time.Second,
        }
}</span>

// checkServiceHealth verifies if the calculator service is available
func checkServiceHealth(config Configuration) bool <span class="cov0" title="0">{
        client := &amp;http.Client{
                Timeout: config.Timeout,
        }

        resp, err := client.Get(fmt.Sprintf("%s/health", config.ServerURL))
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Health check failed: %v\n", err)
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error closing response body: %v\n", err)
                }</span>
        }()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                fmt.Printf("Health check failed with status: %s\n", resp.Status)
                return false
        }</span>

        <span class="cov0" title="0">var healthResp map[string]bool
        if err := json.NewDecoder(resp.Body).Decode(&amp;healthResp); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to parse health response: %v\n", err)
                return false
        }</span>

        <span class="cov0" title="0">return healthResp["status"]</span>
}

// processCommand processes the user command and calls the API
func processCommand(input string, config Configuration) (int, error) <span class="cov0" title="0">{
        // Split the input into command and arguments
        parts := strings.Fields(input)
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid input, expected format: &lt;operation&gt; &lt;number1&gt; &lt;number2&gt;")
        }</span>

        <span class="cov0" title="0">operation := strings.ToLower(parts[0])
        
        // Validate operation
        switch operation </span>{
        case "add", "subtract", "multiply", "divide":<span class="cov0" title="0"></span>
                // Valid operations
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unknown operation: %s, supported operations are add, subtract, multiply, and divide", operation)</span>
        }

        // Parse the numbers
        <span class="cov0" title="0">a, err := strconv.Atoi(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("first number is invalid: %v", err)
        }</span>

        <span class="cov0" title="0">b, err := strconv.Atoi(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("second number is invalid: %v", err)
        }</span>

        // Prepare the API request
        <span class="cov0" title="0">reqBody := CalculationRequest{
                Operation: operation,
                A:         a,
                B:         b,
        }

        return callCalculateAPI(reqBody, config)</span>
}

// callCalculateAPI calls the calculate API endpoint
func callCalculateAPI(req CalculationRequest, config Configuration) (int, error) <span class="cov0" title="0">{
        // Create HTTP client with timeout
        client := &amp;http.Client{
                Timeout: config.Timeout,
        }

        // Convert request to JSON
        jsonData, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to marshal request: %v", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">httpReq, err := http.NewRequest("POST", fmt.Sprintf("%s/calculate", config.ServerURL), bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create request: %v", err)
        }</span>
        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        // Send the request
        resp, err := client.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("request failed: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error closing response body: %v\n", err)
                }</span>
        }()

        // Read response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read response: %v", err)
        }</span>

        // Check for non-200 status code
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        // Parse the response
        <span class="cov0" title="0">var calcResp CalculationResponse
        if err := json.Unmarshal(body, &amp;calcResp); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse response: %v", err)
        }</span>

        // Check for API errors
        <span class="cov0" title="0">if !calcResp.Success </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("API error: %s", calcResp.Error)
        }</span>

        <span class="cov0" title="0">return calcResp.Result, nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main implements a calculator microservice
package main

import (
        "encoding/json"
        "flag"
        "fmt"
        "go-examples/pkg/calculator"
        "go-examples/pkg/logger"
        "go-examples/pkg/slogger"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "github.com/gorilla/mux"
        "go.uber.org/zap/zapcore"
)

// LoggerInterface defines a common interface for both logging systems
type LoggerInterface interface {
        Info(args ...interface{})
        Error(args ...interface{})
        Debug(args ...interface{})
        Warn(args ...interface{})
        Fatal(args ...interface{})
        
        Infof(template string, args ...interface{})
        Errorf(template string, args ...interface{})
        Warnf(template string, args ...interface{})
        Fatalf(template string, args ...interface{})
}

// SlogAdapter adapts the slogger to our common interface
type SlogAdapter struct {
        logger slogger.Logger
}

// Info logs an informational message
func (s *SlogAdapter) Info(args ...interface{}) <span class="cov0" title="0">{
        // Convert args to a message string and any key-value pairs
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                msg, ok := args[0].(string)
                if ok </span><span class="cov0" title="0">{
                        s.logger.Info(msg, args[1:]...)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Info("info", args...)
                }</span>
        }
}

// Error logs an error message
func (s *SlogAdapter) Error(args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                msg, ok := args[0].(string)
                if ok </span><span class="cov0" title="0">{
                        s.logger.Error(msg, args[1:]...)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Error("error", args...)
                }</span>
        }
}

// Debug logs a debug message (maps to Info in slogger)
func (s *SlogAdapter) Debug(args ...interface{}) <span class="cov0" title="0">{
        // slogger doesn't have a Debug method, so use Info
        s.Info(args...)
}</span>

// Warn logs a warning message (maps to Info in slogger)
func (s *SlogAdapter) Warn(args ...interface{}) <span class="cov0" title="0">{
        // slogger doesn't have a Warn method, so use Info
        s.Info(args...)
}</span>

// Fatal logs a fatal error message and exits the program
func (s *SlogAdapter) Fatal(args ...interface{}) <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                msg, ok := args[0].(string)
                if ok </span><span class="cov0" title="0">{
                        s.logger.Fatal(msg, args[1:]...)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Fatal("fatal", args...)
                }</span>
        }
}

// Infof logs an informational message with formatting
func (s *SlogAdapter) Infof(template string, args ...interface{}) <span class="cov0" title="0">{
        // slogger doesn't have formatted methods, so we'll format it ourselves
        s.logger.Info(fmt.Sprintf(template, args...))
}</span>

// Errorf logs an error message with formatting
func (s *SlogAdapter) Errorf(template string, args ...interface{}) <span class="cov0" title="0">{
        s.logger.Error(fmt.Sprintf(template, args...))
}</span>

// Warnf logs a warning message with formatting
func (s *SlogAdapter) Warnf(template string, args ...interface{}) <span class="cov0" title="0">{
        // slogger doesn't have Warn, so use Info
        s.logger.Info("WARN: " + fmt.Sprintf(template, args...))
}</span>

// Fatalf logs a fatal error message with formatting and exits the program
func (s *SlogAdapter) Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{
        s.logger.Fatal(fmt.Sprintf(template, args...))
}</span>

// calculatorLoggerAdapter adapts our common interface to the calculator's logger interface
type calculatorLoggerAdapter struct {
        log LoggerInterface
}

func (a *calculatorLoggerAdapter) Debug(args ...interface{})              <span class="cov0" title="0">{ a.log.Debug(args...) }</span>
func (a *calculatorLoggerAdapter) Info(args ...interface{})               <span class="cov0" title="0">{ a.log.Info(args...) }</span>
func (a *calculatorLoggerAdapter) Warn(args ...interface{})               <span class="cov0" title="0">{ a.log.Warn(args...) }</span>
func (a *calculatorLoggerAdapter) Error(args ...interface{})              <span class="cov0" title="0">{ a.log.Error(args...) }</span>
func (a *calculatorLoggerAdapter) Fatal(args ...interface{})              <span class="cov0" title="0">{ a.log.Fatal(args...) }</span>
func (a *calculatorLoggerAdapter) Debugf(template string, args ...interface{})   <span class="cov0" title="0">{ a.log.Infof(template, args...) }</span>
func (a *calculatorLoggerAdapter) Infof(template string, args ...interface{})    <span class="cov0" title="0">{ a.log.Infof(template, args...) }</span>
func (a *calculatorLoggerAdapter) Warnf(template string, args ...interface{})    <span class="cov0" title="0">{ a.log.Infof(template, args...) }</span>
func (a *calculatorLoggerAdapter) Errorf(template string, args ...interface{})   <span class="cov0" title="0">{ a.log.Errorf(template, args...) }</span>
func (a *calculatorLoggerAdapter) Fatalf(template string, args ...interface{})   <span class="cov0" title="0">{ a.log.Fatal(fmt.Sprintf(template, args...)) }</span>
func (a *calculatorLoggerAdapter) With(_ ...interface{}) logger.Logger <span class="cov0" title="0">{ return a }</span>

// Configuration holds all the server configuration
type Configuration struct {
        Port      int
        LogLevel  string
        LogSystem string // "zap" or "slog"
}

// CalculationRequest represents a calculation API request
type CalculationRequest struct {
        Operation string `json:"operation"`
        A         int    `json:"a"`
        B         int    `json:"b"`
}

// CalculationResponse represents a calculation API response
type CalculationResponse struct {
        Result  int    `json:"result"`
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

func main() <span class="cov0" title="0">{
        // Parse configuration from command line flags
        config := parseFlags()

        // Initialize logger
        log, err := setupLogger(config)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">log.Info("Starting calculator microservice")
        log.Infof("Using %s logging system", config.LogSystem)

        // Create calculator instance with logger
        var calcLogger logger.Logger
        if zapLogger, ok := log.(logger.Logger); ok </span><span class="cov0" title="0">{
                // If it's the original logger, use it directly
                calcLogger = zapLogger
        }</span> else<span class="cov0" title="0"> {
                // If it's the slog adapter, create a simple adapter for the calculator
                // The calculator expects the original logger interface
                calcLogger = &amp;calculatorLoggerAdapter{log: log}
        }</span>
        <span class="cov0" title="0">calc := calculator.NewCalculator(calcLogger)

        // Set up API routes
        router := mux.NewRouter()
        router.HandleFunc("/calculate", createCalculateHandler(calc, log)).Methods("POST")
        router.HandleFunc("/health", healthCheckHandler).Methods("GET")

        // Start server
        serverAddr := fmt.Sprintf(":%d", config.Port)
        log.Infof("Server starting on %s", serverAddr)
        
        // Create a server with graceful shutdown and security settings
        server := &amp;http.Server{
                Addr:              serverAddr,
                Handler:           router,
                ReadHeaderTimeout: 5 * time.Second, // Prevent Slowloris attacks
        }

        // Start the server in a goroutine
        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Server failed: %v", err)
                }</span>
        }()

        // Set up signal handling for graceful shutdown
        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

        // Wait for interrupt signal
        &lt;-stop
        log.Info("Shutting down server...")
        log.Info("Server stopped")</span>
}

// parseFlags parses command line flags and returns configuration
func parseFlags() Configuration <span class="cov0" title="0">{
        port := flag.Int("port", 8080, "Server port")
        logLevel := flag.String("log-level", "info", "Log level (debug, info, warn, error)")
        logSystem := flag.String("log-system", "zap", "Logging system to use (zap or slog)")
        flag.Parse()

        return Configuration{
                Port:      *port,
                LogLevel:  *logLevel,
                LogSystem: strings.ToLower(*logSystem),
        }
}</span>

// setupLogger creates and configures the logger based on the configuration
func setupLogger(config Configuration) (LoggerInterface, error) <span class="cov0" title="0">{
        switch config.LogSystem </span>{
        case "slog":<span class="cov0" title="0">
                // Initialize structured logger (slogger)
                slog := slogger.InitLogging()
                return &amp;SlogAdapter{logger: slog}, nil</span>
                
        case "zap", "":<span class="cov0" title="0">
                // Initialize zap logger (original logger)
                var zapLevel zapcore.Level
                
                switch config.LogLevel </span>{
                case "debug":<span class="cov0" title="0">
                        zapLevel = zapcore.DebugLevel</span>
                case "info":<span class="cov0" title="0">
                        zapLevel = zapcore.InfoLevel</span>
                case "warn":<span class="cov0" title="0">
                        zapLevel = zapcore.WarnLevel</span>
                case "error":<span class="cov0" title="0">
                        zapLevel = zapcore.ErrorLevel</span>
                default:<span class="cov0" title="0">
                        zapLevel = zapcore.InfoLevel</span>
                }
                
                // Using NewCustom which doesn't return error
                <span class="cov0" title="0">return logger.NewCustom(zapLevel, true), nil</span>
                
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown log system: %s, supported systems are 'zap' and 'slog'", config.LogSystem)</span>
        }
}

// createCalculateHandler returns an HTTP handler for calculator operations
func createCalculateHandler(calc *calculator.Calculator, log LoggerInterface) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Parse request
                var req CalculationRequest
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        sendErrorResponse(w, "Invalid request format", http.StatusBadRequest, log)
                        return
                }</span>

                <span class="cov0" title="0">log.Infof("Calculation request: %+v", req)

                // Process calculation
                var result int

                switch req.Operation </span>{
                case "add":<span class="cov0" title="0">
                        result = calc.Add(req.A, req.B)</span>
                case "subtract":<span class="cov0" title="0">
                        result = calc.Subtract(req.A, req.B)</span>
                case "multiply":<span class="cov0" title="0">
                        result = calc.Multiply(req.A, req.B)</span>
                case "divide":<span class="cov0" title="0">
                        if req.B == 0 </span><span class="cov0" title="0">{
                                sendErrorResponse(w, "Division by zero", http.StatusBadRequest, log)
                                return
                        }</span>
                        <span class="cov0" title="0">result = calc.Divide(req.A, req.B)</span>
                default:<span class="cov0" title="0">
                        sendErrorResponse(w, "Unknown operation: "+req.Operation, http.StatusBadRequest, log)
                        return</span>
                }

                // Send successful response
                <span class="cov0" title="0">resp := CalculationResponse{
                        Result:  result,
                        Success: true,
                }

                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Failed to encode response: %v", err)
                }</span>
        }
}

// healthCheckHandler handles health check requests
func healthCheckHandler(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        if err := json.NewEncoder(w).Encode(map[string]bool{"status": true}); err != nil </span><span class="cov0" title="0">{
                // This would rarely happen, but we should handle it
                w.WriteHeader(http.StatusInternalServerError)
        }</span>
}

// sendErrorResponse sends an error response with the given message and status code
func sendErrorResponse(w http.ResponseWriter, message string, statusCode int, log LoggerInterface) <span class="cov0" title="0">{
        log.Warnf("Error response: %s (code: %d)", message, statusCode)
        resp := CalculationResponse{
                Success: false,
                Error:   message,
        }

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Errorf("Failed to encode error response: %v", err)
                // In case we can't encode the JSON response, send a plain text error
                http.Error(w, "Internal server error", http.StatusInternalServerError)
        }</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">// Package badstructure demonstrates problematic Go package organization.
// This example shows what NOT to do when organizing Go code.
package badstructure

import (
        "fmt"
)

// This would typically be in a separate file but the same package
// We're putting everything in one file to demonstrate problems

// Problem 1: Mixed Concerns
// The same package contains unrelated functionalities (DB and HTTP utils)

// Database represents a database connection
type Database struct {
        URL      string
        Username string
        Password string
}

// HTTPClient represents an HTTP client
type HTTPClient struct {
        BaseURL    string
        UserAgent  string
        MaxRetries int
}

// Problem 2: Name conflicts with methods
// Both types have "Connect" methods, forcing awkward usage patterns

// Connect establishes a database connection
func (db Database) Connect() error <span class="cov0" title="0">{
        fmt.Printf("Connecting to database at %s\n", db.URL)
        return nil
}</span>

// Connect establishes an HTTP connection
// This compiles but leads to confusing usage:
// - db.Connect() and client.Connect() do very different things
// - No namespace separation despite different purposes
func (client HTTPClient) Connect() error <span class="cov0" title="0">{
        fmt.Printf("Connecting to HTTP service at %s\n", client.BaseURL)
        return nil
}</span>

// Problem 3: No encapsulation between components
// The validate function is reused inappropriately across components

func validate(s string) bool <span class="cov0" title="0">{
        return len(s) &gt; 0
}</span>

// ValidateDatabase checks database settings
func ValidateDatabase(db Database) bool <span class="cov0" title="0">{
        // Reuses the same validation logic for completely different types
        return validate(db.URL) &amp;&amp; validate(db.Username)
}</span>

// ValidateHTTPClient checks HTTP client settings
func ValidateHTTPClient(client HTTPClient) bool <span class="cov0" title="0">{
        // Reuses the same validation logic intended for DB validation
        return validate(client.BaseURL) &amp;&amp; validate(client.UserAgent)
}</span>

/*
PROBLEMS WITH THIS STRUCTURE:

1. Poor Separation of Concerns:
   - Database and HTTP functionality are mixed in one package
   - No logical boundaries between different components
   - Difficult to understand which parts relate to each other

2. Name Conflicts:
   - Methods with the same name on different types cause confusion
   - No namespacing to differentiate between components
   - Users must understand implementation details to know what each method does

3. Inappropriate Code Reuse:
   - Shared functions used across unrelated components
   - Changes to shared functions affect multiple systems unintentionally

4. Import Problems:
   - Importing this package pulls in ALL functionality, even if just one part is needed
   - No way to import just the database or just the HTTP components

5. Maintenance Nightmare:
   - Adding new functionality may require checking all existing code for conflicts
   - Changing "validate" affects both database and HTTP validation
   - No clear ownership of specific pieces of code

Better Approach:
   - Split into separate packages: "database" and "http"
   - Each package would be in its own directory with clear responsibility
   - Methods can have the same names without conflicts: database.Connect() vs http.Connect()
*/

</pre>
		
		<pre class="file" id="file4" style="display: none">// Package goodstructure demonstrates proper Go package organization.
// Note that the package name matches the last component of the directory path.
package goodstructure

import (
        "fmt"
)

// Configuration represents application settings
type Configuration struct {
        DatabaseURL string
        APIKey      string
        Debug       bool
}

// defaultConfig is package-private (not exported)
var defaultConfig = Configuration{
        Debug: true,
}

// NewConfiguration creates a Configuration with defaults
func NewConfiguration() Configuration <span class="cov0" title="0">{
        return defaultConfig
}</span>

// PrintInfo is a public function that prints configuration info
func PrintInfo(config Configuration) <span class="cov0" title="0">{
        fmt.Println("Configuration:")
        fmt.Printf("  Database: %s\n", maskSensitiveData(config.DatabaseURL))
        fmt.Printf("  Debug: %v\n", config.Debug)
}</span>

// maskSensitiveData is package-private (not exported)
// This encapsulation keeps implementation details hidden
func maskSensitiveData(data string) string <span class="cov0" title="0">{
        if len(data) &lt; 5 </span><span class="cov0" title="0">{
                return "***"
        }</span>
        <span class="cov0" title="0">return data[:3] + "..." + data[len(data)-3:]</span>
}

/*
ADVANTAGES OF THIS STRUCTURE:

1. Clear Package Boundaries:
   - Package name matches directory name
   - All related functionality is grouped together
   - Proper encapsulation with private functions (lowercase) and public APIs (uppercase)

2. Import Clarity:
   - Importing this package is clear: "go-examples/examples/good_structure"
   - Usage is intuitive: goodstructure.NewConfiguration()

3. Maintainability:
   - Adding new functionality is straightforward - just add more files to this directory
   - All implementation details stay encapsulated in the package
   - Clear separation between public API and private implementation

4. Testability:
   - Package boundaries create natural units for testing
   - Public APIs are clearly defined for test cases
*/

</pre>
		
		<pre class="file" id="file5" style="display: none">// Package examples demonstrates how Go's package structure works.
// This example shows the relationship between directory structure and package imports.
package examples

import (
        "fmt"
        
        // Import packages by their full module path + directory path
        "go-examples/pkg/calculator" // Imports the calculator package from pkg/calculator directory
        "go-examples/pkg/logger"     // Imports the logger package from pkg/logger directory
)

// PackageExample demonstrates Go's package structure 
func PackageExample() <span class="cov0" title="0">{
        // Initialize a logger
        log, err := logger.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to initialize logger: %v\n", err)
                return
        }</span>
        
        // Create a calculator with the logger
        <span class="cov0" title="0">calc := calculator.NewCalculator(log)
        
        // Use the calculator
        result := calc.Add(10, 20)
        
        // When we import "go-examples/pkg/calculator", we're referring to the package
        // defined in the directory "pkg/calculator". All files in that directory 
        // must belong to the same package named "calculator".
        fmt.Printf("Result: %d\n", result)
        
        // Why this structure is maintainable:
        fmt.Println("\nWhy Go's package structure is maintainable:")
        fmt.Println("1. Clear 1:1 mapping between directory names and package names")
        fmt.Println("2. Easy to locate code - if you want calculator functionality, look in pkg/calculator")
        fmt.Println("3. Packages are self-contained units - all calculator code is in one place")
        fmt.Println("4. Prevents circular dependencies due to package boundaries")
        fmt.Println("5. Allows for better organization of larger codebases")
        fmt.Println("6. Import paths clearly indicate where code comes from")</span>
}

/*
Go Package Structure Best Practices:

1. Package == Directory
   - Each directory corresponds to exactly one package
   - All files in a directory must belong to the same package
   - The package name is typically the same as the directory name

2. Import Path vs Package Name
   - Import path: full path from module root (e.g., "go-examples/pkg/calculator")
   - Package name: just the name used in code (e.g., "calculator")
   
3. Standard Project Layout
   /cmd           - Main applications
   /pkg           - Library code that can be used by external applications
   /internal      - Private library code
   /api           - API definitions (OpenAPI/Swagger, protocol buffers, etc)
   /web           - Web assets
   /configs       - Configuration files
   /test          - Additional test applications and test data
   
4. Advantages
   - Easier navigation - directory structure maps to logical components
   - Better encapsulation - package boundaries enforce clean interfaces
   - Improved maintainability - related code stays together
   - Clearer dependencies - explicit import paths show relationships
*/

</pre>
		
		<pre class="file" id="file6" style="display: none">// Package calculator provides arithmetic operations on numbers.
package calculator

import (
        "go-examples/pkg/logger"
)

// Calculator provides arithmetic operations with logging capabilities
type Calculator struct {
        log logger.Logger
}

// NewCalculator creates a new Calculator instance with the provided logger
func NewCalculator(log logger.Logger) *Calculator <span class="cov8" title="1">{
        return &amp;Calculator{
                log: log,
        }
}</span>

// Add returns the sum of two integers.
// It's a simple function to demonstrate Go package functionality.
func (c *Calculator) Add(a, b int) int <span class="cov8" title="1">{
        c.log.Infof("Calculating addition: %d + %d", a, b)
        result := a + b
        c.log.Debugf("Addition result: %d", result)
        return result
}</span>

// Subtract returns the difference between two integers.
// It subtracts the second argument from the first.
func (c *Calculator) Subtract(a, b int) int <span class="cov8" title="1">{
        c.log.Infof("Calculating subtraction: %d - %d", a, b)
        result := a - b
        c.log.Debugf("Subtraction result: %d", result)
        return result
}</span>

// Multiply returns the product of two integers.
// It multiplies the first argument by the second.
func (c *Calculator) Multiply(a, b int) int <span class="cov8" title="1">{
        c.log.Infof("Calculating multiplication: %d * %d", a, b)
        result := a * b
        c.log.Debugf("Multiplication result: %d", result)
        return result
}</span>

// Divide returns the quotient of two integers.
// It divides the first argument by the second.
func (c *Calculator) Divide(a, b int) int <span class="cov8" title="1">{
        c.log.Infof("Calculating division: %d / %d", a, b)
        if b == 0 </span><span class="cov8" title="1">{
                c.log.Error("Division by zero")
                return 0
        }</span>
        <span class="cov8" title="1">result := a / b
        c.log.Debugf("Division result: %d", result)
        return result</span>
}

// For backward compatibility with existing code, keep the original functions
// but they now use a default no-op logger

// Add returns the sum of two integers.
func Add(a, b int) int <span class="cov8" title="1">{
        // Create a calculator with a no-op logger for backward compatibility
        calc := NewCalculator(noOpLogger{})
        return calc.Add(a, b)
}</span>

// Subtract returns the difference between two integers.
func Subtract(a, b int) int <span class="cov8" title="1">{
        // Create a calculator with a no-op logger for backward compatibility
        calc := NewCalculator(noOpLogger{})
        return calc.Subtract(a, b)
}</span>

// Multiply returns the product of two integers.
func Multiply(a, b int) int <span class="cov8" title="1">{
        // Create a calculator with a no-op logger for backward compatibility
        calc := NewCalculator(noOpLogger{})
        return calc.Multiply(a, b)
}</span>

// Divide returns the quotient of two integers.
func Divide(a, b int) int <span class="cov8" title="1">{
        // Create a calculator with a no-op logger for backward compatibility
        calc := NewCalculator(noOpLogger{})
        return calc.Divide(a, b)
}</span>

// noOpLogger is a no-operation logger for backward compatibility
type noOpLogger struct{}

func (l noOpLogger) Debug(_ ...interface{})              {<span class="cov0" title="0">}</span>
func (l noOpLogger) Info(_ ...interface{})               {<span class="cov0" title="0">}</span>
func (l noOpLogger) Warn(_ ...interface{})               {<span class="cov0" title="0">}</span>
func (l noOpLogger) Error(_ ...interface{})              {<span class="cov0" title="0">}</span>
func (l noOpLogger) Fatal(_ ...interface{})              {<span class="cov0" title="0">}</span>
func (l noOpLogger) Debugf(_ string, _ ...interface{})   {<span class="cov8" title="1">}</span>
func (l noOpLogger) Infof(_ string, _ ...interface{})    {<span class="cov8" title="1">}</span>
func (l noOpLogger) Warnf(_ string, _ ...interface{})    {<span class="cov0" title="0">}</span>
func (l noOpLogger) Errorf(_ string, _ ...interface{})   {<span class="cov0" title="0">}</span>
func (l noOpLogger) Fatalf(_ string, _ ...interface{})   {<span class="cov0" title="0">}</span>
func (l noOpLogger) With(_ ...interface{}) logger.Logger <span class="cov0" title="0">{ return l }</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package logger provides a centralized logging configuration
// based on uber-go/zap.
package logger

import (
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger is the global logger interface
type Logger interface {
        Debug(args ...interface{})
        Info(args ...interface{})
        Warn(args ...interface{})
        Error(args ...interface{})
        Fatal(args ...interface{})

        Debugf(template string, args ...interface{})
        Infof(template string, args ...interface{})
        Warnf(template string, args ...interface{})
        Errorf(template string, args ...interface{})
        Fatalf(template string, args ...interface{})

        With(args ...interface{}) Logger
}

// zapLogger wraps zap.SugaredLogger to implement our Logger interface
type zapLogger struct {
        sugar *zap.SugaredLogger
}

// NewDevelopment creates a logger with development-friendly defaults
func NewDevelopment() (Logger, error) <span class="cov8" title="1">{
        logger, err := zap.NewDevelopment()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sugar := logger.Sugar()
        return &amp;zapLogger{sugar: sugar}, nil</span>
}

// NewProduction creates a logger with production-friendly defaults
func NewProduction() (Logger, error) <span class="cov8" title="1">{
        logger, err := zap.NewProduction()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sugar := logger.Sugar()
        return &amp;zapLogger{sugar: sugar}, nil</span>
}

// NewCustom creates a logger with custom configuration
func NewCustom(level zapcore.Level, isProduction bool) Logger <span class="cov8" title="1">{
        // Create encoder config based on environment
        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "ts",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        // Use JSON encoder for production, console encoder for development
        var encoder zapcore.Encoder
        if isProduction </span><span class="cov8" title="1">{
                encoder = zapcore.NewJSONEncoder(encoderConfig)
        }</span> else<span class="cov8" title="1"> {
                encoder = zapcore.NewConsoleEncoder(encoderConfig)
        }</span>

        // Configure output
        <span class="cov8" title="1">core := zapcore.NewCore(
                encoder,
                zapcore.AddSync(os.Stdout),
                level,
        )

        // Create logger
        logger := zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))
        return &amp;zapLogger{sugar: logger.Sugar()}</span>
}

// Implementation of Logger interface methods
func (l *zapLogger) Debug(args ...interface{})                   <span class="cov0" title="0">{ l.sugar.Debug(args...) }</span>
func (l *zapLogger) Info(args ...interface{})                    <span class="cov0" title="0">{ l.sugar.Info(args...) }</span>
func (l *zapLogger) Warn(args ...interface{})                    <span class="cov0" title="0">{ l.sugar.Warn(args...) }</span>
func (l *zapLogger) Error(args ...interface{})                   <span class="cov0" title="0">{ l.sugar.Error(args...) }</span>
func (l *zapLogger) Fatal(args ...interface{})                   <span class="cov0" title="0">{ l.sugar.Fatal(args...) }</span>
func (l *zapLogger) Debugf(template string, args ...interface{}) <span class="cov0" title="0">{ l.sugar.Debugf(template, args...) }</span>
func (l *zapLogger) Infof(template string, args ...interface{})  <span class="cov0" title="0">{ l.sugar.Infof(template, args...) }</span>
func (l *zapLogger) Warnf(template string, args ...interface{})  <span class="cov0" title="0">{ l.sugar.Warnf(template, args...) }</span>
func (l *zapLogger) Errorf(template string, args ...interface{}) <span class="cov0" title="0">{ l.sugar.Errorf(template, args...) }</span>
func (l *zapLogger) Fatalf(template string, args ...interface{}) <span class="cov0" title="0">{ l.sugar.Fatalf(template, args...) }</span>

func (l *zapLogger) With(args ...interface{}) Logger <span class="cov0" title="0">{
        return &amp;zapLogger{sugar: l.sugar.With(args...)}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package slogger provides a wrapper around Go's structured logging (slog) package
// with additional features for HTTP response logging.
package slogger

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "os"
)

// Logger is a wrapper around slog that provides simpler methods for common logging levels.
type Logger struct{}

// OsExit is a variable that points to os.Exit to allow for testing
// without actually exiting the program.
var OsExit = os.Exit

// Fatal logs a message at fatal level and then exits the program with status code 1.
func (l *Logger) Fatal(msg string, args ...any) <span class="cov8" title="1">{
        slog.Log(context.Background(), slog.LevelError, msg, args...)
        OsExit(1)
}</span>

// Error logs a message at error level.
func (l *Logger) Error(msg string, args ...any) <span class="cov8" title="1">{
        slog.Log(context.Background(), slog.LevelError, msg, args...)
}</span>

// Info logs a message at info level.
func (l *Logger) Info(msg string, args ...any) <span class="cov8" title="1">{
        slog.Log(context.Background(), slog.LevelInfo, msg, args...)
}</span>

// InitLogging initializes the structured logger with DEBUG level
// and returns a new Logger instance.
func InitLogging() Logger <span class="cov8" title="1">{
        slog.SetLogLoggerLevel(slog.LevelDebug)
        return Logger{}
}</span>

// ResponseLogger provides logging utilities specifically for HTTP responses
// with request context information included.
type ResponseLogger struct {
        requestID string // Unique ID for the request
        logger    *Logger
}

// Response logs information about an HTTP response including status code and URI.
func (l *ResponseLogger) Response(code int, r *http.Request, args ...any) <span class="cov8" title="1">{
        params := append([]any{"code", code, "uri", r.RequestURI}, args...)
        l.logger.Info(l.requestID, params...)
}</span>

// ResponseErrorAndSend logs an error response and sends it to the client.
func (l *ResponseLogger) ResponseErrorAndSend(code int, msg string, r *http.Request, w http.ResponseWriter, args ...any) <span class="cov8" title="1">{
        l.Response(code, r, append([]any{"message", msg}, args...)...)
        http.Error(w, fmt.Sprintf("%d %s", code, msg), code)
}</span>

// NewResponseLogger creates a new ResponseLogger with the specified request ID.
func (l *Logger) NewResponseLogger(requestID string) *ResponseLogger <span class="cov8" title="1">{
        return &amp;ResponseLogger{
                requestID: requestID,
                logger:    l,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
